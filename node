// Load necessary modules and environment variables
require('dotenv').config();
const axios = require('axios');
const crypto = require('crypto');

class OneRoster {
    constructor() {
        // Initialize with client ID and secret from environment variables
        this.clientId = process.env.CLIENT_ID;
        this.clientSecret = process.env.CLIENT_SECRET;
        // Define the base URL and the endpoints to access
        this.baseUrl = "https://api.classlink.com/oneroster";
        this.collections = ["academicSessions", "orgs", "courses", "classes", "users", "enrollments", "demographics"];
    }

    // Main method to fetch all data from each collection
    async fetchAllData() {
        for (const collection of this.collections) {
            const url = `${this.baseUrl}/${collection}`;
            await this.fetchCollection(url);
        }
    }

    // Fetch data from a single collection with pagination
    async fetchCollection(url) {
        let limit = 10000; // Maximum number of items per page
        let offset = 0; // Start at the beginning
        let totalCount = null; // Total number of items in the collection
        let runningTotal = 0; // Counter for items fetched
        let retries = 0; // Counter for retry attempts

        // Continue fetching until all data is retrieved
        while (totalCount === null || runningTotal < totalCount) {
            try {
                const data = await this.makeRosterRequest(url, limit, offset);
                if (data.status !== 200) {
                    // Handle rate limiting and server errors
                    if ([429, 502].includes(data.status)) {
                        retries = await this.handleRateLimits(retries, data.status);
                    }
                    continue;
                }
                const pageData = data.data;
                const count = pageData.length;
                runningTotal += count;
                totalCount = parseInt(data.headers['x-total-count']);
                offset += limit;
            } catch (error) {
                console.error("Failed to fetch data: ", error);
                break;
            }
        }
    }

    // Construct the full URL and make the HTTP GET request
    async makeRosterRequest(url, limit, offset) {
        url += `?limit=${limit}&offset=${offset}`;
        return axios.get(url, { headers: { Authorization: this.buildAuthHeader() } });
    }

    // Implement exponential backoff with jitter for rate limits
    async handleRateLimits(retries, errorCode) {
        const waitTime = Math.pow(2, retries) + Math.random();
        await new Promise(resolve => setTimeout(resolve, waitTime * 1000));
        retries += 1;
        if (retries > 5) {
            throw new Error(`API request failed after several retries due to error ${errorCode}`);
        }
        return retries;
    }

    // Construct the OAuth authorization header
    buildAuthHeader() {
        const method = 'GET';
        const timestamp = Math.floor(Date.now() / 1000);
        const nonce = this.generateNonce(10);
        const params = {
            oauth_consumer_key: this.clientId,
            oauth_signature_method: 'HMAC-SHA256',
            oauth_timestamp: timestamp,
            oauth_nonce: nonce
        };
        const baseString = this.buildBaseString(this.baseUrl, method, params);
        const signature = this.generateAuthSignature(baseString);
        const authHeader = `OAuth oauth_signature="${encodeURIComponent(signature)}"`;
        return authHeader;
    }

    // Generate a random string (nonce) for the OAuth signature
    generateNonce(length) {
        const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        return Array.from({ length }, () => possible[Math.floor(Math.random() * possible.length)]).join('');
    }

    // Build the base string for the OAuth signature
    buildBaseString(url, method, params) {
        const sortedKeys = Object.keys(params).sort();
        const paramStr = sortedKeys.map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`).join('&');
        return `${method}&${encodeURIComponent(url)}&${encodeURIComponent(paramStr)}`;
    }

    // Generate the HMAC-SHA256 signature for OAuth
    generateAuthSignature(baseString) {
        const key = `${encodeURIComponent(this.clientSecret)}&`;
        const hmac = crypto.createHmac('sha256', key).update(baseString).digest('base64');
        return hmac;
    }
}

// Usage example: create an instance and fetch all data
(async () => {
    const roster = new OneRoster();
    await roster.fetchAllData();
})();
