import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpHeaders;
import java.net.URLEncoder;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class OneRoster {
    private String clientId;
    private String clientSecret;
    private String baseUrl;
    private String[] collections = {"academicSessions", "orgs", "courses", "classes", "users", "enrollments", "demographics"};

    public OneRoster() {
        this.clientId = System.getenv("CLIENT_ID");
        this.clientSecret = System.getenv("CLIENT_SECRET");
        this.baseUrl = "https://api.classlink.com/oneroster";
    }

    public void fetchAllData() throws IOException, InterruptedException {
        for (String collection : collections) {
            String url = baseUrl + "/" + collection;
            fetchCollection(url);
        }
    }

    private void fetchCollection(String url) throws IOException, InterruptedException {
        int limit = 10000;
        int offset = 0;
        int totalCount = -1;
        int runningTotal = 0;

        while (totalCount == -1 || runningTotal < totalCount) {
            HttpResponse<String> response = makeRosterRequest(url, limit, offset);
            int statusCode = response.statusCode();
            if (statusCode != 200) {
                handleRateLimits(statusCode);
                continue;
            }
            Map<String, String> headers = parseHeaders(response.headers());
            String jsonData = response.body();
            int count = countData(jsonData); // Implement this based on your JSON structure
            runningTotal += count;
            totalCount = Integer.parseInt(headers.get("x-total-count"));
            offset += limit;
        }
    }

    private HttpResponse<String> makeRosterRequest(String url, int limit, int offset) throws IOException, InterruptedException {
        HttpClient client = HttpClient.newHttpClient();
        String fullUrl = String.format("%s?limit=%d&offset=%d", url, limit, offset);
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(fullUrl))
            .header("Authorization", buildAuthHeader())
            .build();
        return client.send(request, HttpResponse.BodyHandlers.ofString());
    }

    private void handleRateLimits(int statusCode) throws InterruptedException {
        if (statusCode == 429 || statusCode == 502) {
            Thread.sleep(1000); // Simple backoff, should be more sophisticated
        }
    }

    private String buildAuthHeader() throws NoSuchAlgorithmException {
        String method = "GET";
        String timestamp = String.valueOf(System.currentTimeMillis() / 1000);
        String nonce = generateNonce(10);
        Map<String, String> params = new HashMap<>();
        params.put("oauth_consumer_key", clientId);
        params.put("oauth_signature_method", "HMAC-SHA256");
        params.put("oauth_timestamp", timestamp);
        params.put("oauth_nonce", nonce);

        String baseString = buildBaseString(baseUrl, method, params);
        String signature = generateAuthSignature(baseString);
        return "OAuth oauth_signature=\"" + URLEncoder.encode(signature, "UTF-8") + "\"";
    }

    private String generateNonce(int length) {
        Random random = new Random();
        return random.ints(48, 122)
                     .filter(i -> (i <= 57 || i >= 65) && (i <= 90 || i >= 97))
                     .limit(length)
                     .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
                     .toString();
    }

    private String buildBaseString(String url, String method, Map<String, String> params) {
        String paramStr = params.entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .map(e -> URLEncoder.encode(e.getKey(), "UTF-8") + "=" + URLEncoder.encode(e.getValue(), "UTF-8"))
            .collect(Collectors.joining("&"));
        return method + "&" + URLEncoder.encode(url, "UTF-8") + "&" + URLEncoder.encode(paramStr, "UTF-8");
    }

    private String generateAuthSignature(String baseString) throws NoSuchAlgorithmException {
        String key = URLEncoder.encode(clientSecret, "UTF-8") + "&";
        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key.getBytes(), "HmacSHA256"));
        byte[] signatureBytes = mac.doFinal(baseString.getBytes());
        return Base64.getEncoder().encodeToString(signatureBytes);
    }

    private Map<String, String> parseHeaders(HttpHeaders headers) {
        return headers.map().entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().get(0)
            ));
    }

    private int countData(String jsonData) {
        // Implement JSON parsing and counting logic here
        return 0;
    }

    public static void main(String[] args) {
        try {
            OneRoster roster = new OneRoster();
            roster.fetchAllData();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
