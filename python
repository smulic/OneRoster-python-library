import os
import time
import random
from random import randint
from urllib.parse import quote, quote_plus, unquote
import hmac
import base64
import hashlib
import requests
from collections import OrderedDict
from dotenv import load_dotenv


class OneRoster:
    def __init__(self):
        load_dotenv
        # Load API credentials from environment variables for security
        self._client_id = os.getenv('CLIENT_ID')
        self._client_secret = os.getenv('CLIENT_SECRET')
        # Base URL for all API requests
        self.base_url = os.getenv('BASE_URL')
        # List of data collections to be fetched
        self.collections = ["academicSessions", "orgs", "courses", "classes", "users", "enrollments", "demographics"]
        self.responseCount = 0

    def fetch_all_data(self):
        # Iterate over each collection and fetch all data
        for collection in self.collections:
            url = f"{self.base_url}/{collection}"
            self._fetch_collection(url, collection)

    def _fetch_collection(self, url: str, collection: str):
        # Pagination settings: fetch data in batches of 10,000 records
        limit = 10000
        offset = 0
        total_count = None
        running_total = 0
        retries = 0
        final_res = []

        # Continue fetching data until all records are retrieved
        while total_count is None or running_total < total_count:
            data = self.make_roster_request(url, limit, offset)
            # Check for HTTP error statuses
            if 'status_code' in data and data['status_code'] != 200:
                if data['status_code'] in [*range(429, 503, 1)]:
                    retries = self._handle_rate_limits(retries, data['status_code'])
                continue
            page_data = data['response'][collection]
            final_res.append(page_data)
            count = len(page_data)
            running_total += count
            if 'x-total-count' in data:
                total_count = int(data['x-total-count'])
            offset += limit
            print(f"running total: {running_total}")
            print(f"total count: {total_count}")
        return final_res

    def make_roster_request(self, url: str, limit: int, offset: int) -> dict:
        # Append pagination parameters to the URL
        # url += f"?limit={limit}&offset={offset}"
        return self._make_get_request(url)

    # def _handle_rate_limits(self, retries: int, error_code: int):
    #     # Exponential backoff with jitter for handling rate limits and server errors
    #     wait_time = (2 ** retries) + random.uniform(0, 1)
    #     time.sleep(wait_time)
    #     retries += 1
    #     if retries > 5:  # Prevent infinite retry loops
    #         print(f"API request failed after several retries due to error {error_code}")
    #         raise Exception(f"API request failed after several retries due to error {error_code}")
    #     return retries

    def _handle_rate_limits(self, retries, error_code):
        if error_code in [500, 502, 503, 429]:  # Including common server error codes
            wait_time = (2 ** retries) + random.uniform(0, 1)
            print(f"Rate limit or server error encountered. Waiting {wait_time:.2f} seconds before retrying...")
            time.sleep(wait_time)
            retries += 1
            if retries >= 5:
                raise Exception(f"API request failed after {retries} retries due to error {error_code}")
        return retries

    def _make_get_request(self, url: str) -> dict:
        # Execute the HTTP GET request with OAuth authentication
        try:
            response = requests.get(url=url, headers={'Authorization': self._build_auth_header(url)})
            self.responseCount += 1
            response.raise_for_status()
            return {
                'status_code': response.status_code,
                'response': response.json(),
                'x-total-count': response.headers.get('x-total-count')
            }
        except requests.exceptions.HTTPError as e:
            print(str(e))
            return {'status_code': e.response.status_code, 'response': str(e)}
        except Exception as e:
            return {'status_code': 0, 'response': str(e)}

    def _build_auth_header(self, url) -> str:
        # Construct OAuth authorization header with signature
        timestamp = str(int(time.time()))
        nonce = self._generate_nonce(len(timestamp))
        oauth = {
            'oauth_consumer_key': self._client_id,
            'oauth_signature_method': 'HMAC-SHA256',
            'oauth_timestamp': timestamp,
            'oauth_nonce': nonce
        }
        base_info = self._build_base_string(url, 'GET', oauth)
        composite_key = quote_plus(self._client_secret) + "&"
        oauth["oauth_signature"] = self._generate_auth_signature(base_info, composite_key)
        auth_parts = [f'{quote_plus(str(k))}="{quote_plus(str(v))}"' for k, v in oauth.items()]
        return "OAuth " + ','.join(auth_parts)

    def _generate_nonce(self, nonce_len: int) -> str:
        # Generate a random string (nonce) for OAuth signature uniqueness
        characters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        return ''.join(characters[randint(0, len(characters) - 1)] for _ in range(nonce_len))

    def _build_base_string(self, baseurl: str, method: str, all_params: dict) -> str:
        # Create the base string used in OAuth signature
        sorted_params = OrderedDict(sorted(all_params.items()))
        param_str = '&'.join(f"{quote(str(k))}={quote(str(v))}" for k, v in sorted_params.items())
        return f"{method}&{quote_plus(baseurl)}&{quote_plus(param_str)}"

    def _generate_auth_signature(self, base_info: str, composite_key: str) -> str:
        # Generate the OAuth signature using HMAC-SHA256
        digest = hmac.new(composite_key.encode(), msg=str.encode(base_info), digestmod=hashlib.sha256).digest()
        return base64.b64encode(digest).decode()

# Usage example:
if __name__ == "__main__":
    roster = OneRoster()
    roster.fetch_all_data()
